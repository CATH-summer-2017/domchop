import numpy as np
from .models import *
import json
### Lets get 2.40.50.140
def select_homsf(sc):
#     sc = "2.40.50.140".split('.');
    sclst = sc.split('.');
    hier = ["Class","arch","topo","homsf","s35","s60","s95","s100"]
    dct = {x:int(y) for x,y in zip(hier,sclst+['0'])}
    # x for x in 
    homsf = classification.objects.get(**dct)
    return homsf


# s0 = StringIO.StringIO();
def preprocess(sfname="2.40.50.140"):
    homsf = select_homsf(sfname);

    xs = [];
    ys = [];
    y2s= [];
    lbls =[];


    for d in homsf.classification_set.all():      
        d = d.domain_set.all()[0]
        vals = get_something( str(d.domain_id),env,s0=s0)
        x = vals['num_nb_pair']
        y = vals['DOPE']
        xs += [x];
        ys += [y];
        y2s+= [d.domain_length]
        lbls+=[d.domain_id];

    return (np.array(xs),np.array(ys),np.array(y2s),lbls)
    
#### The ACTUAL functoinal scripts!!!
import mpld3
import matplotlib as mpl
mpl.use('Agg')

import matplotlib.pyplot as plt

import sys,re
from domutil.util import *
from modeller import *
from modeller.scripts import complete_pdb
import StringIO

with stdoutIO() as s:
    env = environ()
    env.io.atom_files_directory = ['../pdbs','$(PDBlib)/../../dompdb']
    env.libs.topology.read(file='$(LIB)/top_heav.lib')
    env.libs.parameters.read(file='$(LIB)/par.lib')
s0=StringIO.StringIO()
# import StringIO# import 
# from mpld3 import *
# from mpld3 import utils


class HelloWorld(mpld3.plugins.PluginBase):  # inherit from PluginBase
    """The Plugin that controls the behaviour of tooltip"""

    JAVASCRIPT = """
    mpld3.register_plugin("helloworld", HelloWorld);
    HelloWorld.prototype = Object.create(mpld3.Plugin.prototype);
    HelloWorld.prototype.constructor = HelloWorld;
    HelloWorld.prototype.requiredProps = ["id","labels",];
    
    function HelloWorld(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };
    
    HelloWorld.prototype.draw = function(){
       
            
        var obj = mpld3.get_element(this.props.id);
        var labels = (this.props.labels);
        
        obj.elements().on("mousedown",
                          function(d, i){
                          alert("clicked on points[" + labels[i] + "]");
                          //highlight("#row_264173");
                          highlight("#dbid_"+labels[i]);
                          });
    }
    """
    def __init__(self, points,labels):
        self.dict_ = {"type": "helloworld",
                     "id": mpld3.utils.get_id(points),
                     "labels":labels}
        
def scatterplot_json(sfname='1.10.30.10'):
    msg = '';
    plt.close()
    siz = [400,400]
    DPI=100.
    fig = plt.figure(figsize = [x/float(DPI) for x in siz], dpi=DPI)
    # fig.tight_layout()

    # DPI = fig.get_dpi()
    # fig.set_size_inches(400.0/float(DPI),400.0/float(DPI))    

    ax1 = fig.add_subplot(111)


    pdata = preprocess(sfname);

    ### preprocess() returns a tuple of shape (nonbonded_pair_nums, DOPE, domain_length,  domian_id)
    if not pdata:
        y2s,ys,xs,lbls = preprocess(sfname)
    else:
        y2s,ys,xs,lbls = pdata

    ax1.set_xlim([0,500])
    ax1.set_ylim([0,800E3])
    ax1.set_xlabel('Domain length (aa)')
    ax1.set_ylabel('Number nb-interaction pairs')


    ids=[];
    for d in select_homsf(sfname).classification_set.all():
        ids.append((d.domain_set.all()[0].id))

    # points = ax1.scatter(xs,y2s,s=33,marker = 'x',)
    # points = ax1.scatter(xs,y2s,s=30,marker = 'o',color = 'g')
    points = ax1.scatter(xs,y2s,edgecolor = 'b',facecolor = 'none',
        marker ='o',
         s =30)


    try:
        # ((m,b),C) = np.polyfit(xs, y2s, 1, cov =True) ### This covariance seems different from the one generated by np.cov()
        (m,b) = np.polyfit(xs, y2s, 1, cov = False)
        C = np.cov(xs,y2s)
        r_sq = cov2corr(C).flat[1] ** 2
    except Exception as err:
        m = 0.
        b = 0.
        r_sq = 0
        msg += '\nErr:' + str(err);
    res2  = y2s - ( m*xs + b)
    outs = MAD_outlier(res2,3.0)
    outs = outs * (res2<0);
    xso = xs[outs]
    y2so = y2s[outs]
    sc1 = ax1.scatter(xso,y2so,s=33,
        color='r',
        marker = 'x',
        label='outlier num = %d'%sum(outs))

    # title = '''
    # $y  = %s \\cdot x + %s$ \n
    # $R^{2}=%3.3f $'''% (latex_float(m,4),latex_float(b,4),r_sq)

    title = '''
    y  = %5.3f * x + %5.3f 
    R_squared=%3.3f '''% (m,b,r_sq)
    xmm = np.array([min(xs),max(xs)])
    ax1.plot(xmm, m*xmm + b, 'g--',label = 'linear regression fit')

    ax1.legend()

    title +=msg;
    ax1.set_title(
        title)

    tooltip = mpld3.plugins.PointLabelTooltip(points, labels=lbls)
    mpld3.plugins.connect(fig, tooltip)
    mpld3.plugins.connect(fig, HelloWorld(points,ids))
    jdict = mpld3.fig_to_dict(fig);
    jstr = json.dumps(jdict);
    # fig.show()
    # plt.close("all")
#     mpld3.show()
    return([jdict,msg])


# mpld3.save_json(fig,'tmp')